<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Game Né Hiểm Họa Multiplayer</title>
    <style>
        canvas {
            border: 2px solid black;
            display: block;
            margin: 0 auto;
            background: #87CEEB;
        }
        #startScreen, #characterSelectScreen, #nameScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-family: Arial, sans-serif;
        }
        #characterSelectScreen, #nameScreen {
            display: none;
        }
        #startBtn, .characterBtn, #submitNameBtn {
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            background-color: #FF4500;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 10px;
        }
        #startBtn:hover, .characterBtn:hover, #submitNameBtn:hover {
            background-color: #FF6347;
        }
        #restartBtn {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            background-color: #FF4500;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #restartBtn:hover {
            background-color: #FF6347;
        }
        #pauseScreen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-family: Arial, sans-serif;
        }
        #resumeBtn {
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            background-color: #FF4500;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        #resumeBtn:hover {
            background-color: #FF6347;
        }
        #highScores {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    <!-- Thêm Firebase SDK phiên bản mới nhất -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js"></script>
</head>
<body>
    <!-- Phần HTML giữ nguyên như code mày gửi -->
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="startScreen">
        <h2>Game Né Hiểm Họa Multiplayer</h2>
        <p><strong>Hướng dẫn chơi:</strong></p>
        <p>- <strong>Mũi tên lên:</strong> Nhảy (ấn 2 lần để nhảy đôi trong không trung).</p>
        <p>- <strong>Mũi tên xuống:</strong> Cúi để né (nhảy + nhấn xuống để rơi cực nhanh xuống đất).</p>
        <p>- <strong>Mũi tên trái/phái:</strong> Di chuyển qua lại.</p>
        <p>- <strong>Esc:</strong> Tạm dừng trò chơi.</p>
        <p>- <strong>Space (khi thua):</strong> Chơi lại.</p>
        <p>- <strong>Ngôi sao may mắn:</strong> Nhảy lên ăn để tăng mạng (mỗi sao +1 mạng).</p>
        <p>- <strong>Thiên thạch:</strong> Cứ 5 giây xuất hiện, số lượng tăng theo điểm, né để tránh mất mạng.</p>
        <button id="startBtn" onclick="showNameScreen()">Bắt đầu</button>
    </div>
    <div id="nameScreen">
        <h2>Nhập Tên Của Bạn</h2>
        <input type="text" id="playerName" placeholder="Tên của bạn" maxlength="20">
        <br>
        <button id="submitNameBtn" onclick="submitName()">Xác Nhận</button>
    </div>
    <div id="characterSelectScreen">
        <h2>Chọn Nhân Vật</h2>
        <button class="characterBtn" onclick="startGame('ninja')">Ninja</button>
        <button class="characterBtn" onclick="startGame('dinosaur')">Khủng Long</button>
        <button class="characterBtn" onclick="startGame('car')">Xe Ô Tô</button>
        <button class="characterBtn" onclick="startGame('basketball')">Trái Banh Bóng Rổ</button>
    </div>
    <button id="restartBtn" onclick="restartGame()">Chơi Lại</button>
    <div id="pauseScreen">
        <h2>Game Đã Tạm Dừng</h2>
        <p id="countdown"></p>
        <button id="resumeBtn" onclick="resumeGame()">Tiếp Tục Chơi</button>
    </div>
    <div id="highScores">
        <h3>Điểm Cao Nhất</h3>
        <ul id="highScoreList"></ul>
    </div>
    <script>
        // Cấu hình Firebase (giữ nguyên thông tin của mày)
        const firebaseConfig = {
            apiKey: "AIzaSyC69Zmuor5ee_DVsGqfF5EGIPQQAZOh59g",
            authDomain: "let-s-hop-3dde7.firebaseapp.com",
            databaseURL: "https://let-s-hop-3dde7-default-rtdb.firebaseio.com/",
            projectId: "let-s-hop-3dde7",
            storageBucket: "let-s-hop-3dde7.firebasestorage.app",
            messagingSenderId: "554941772864",
            appId: "1:554941772864:web:6cfc1d1f0bd8d95b5e5ba5"
        };

        // Khởi tạo Firebase với try-catch để debug
        let database;
        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            console.log("Firebase initialized successfully");
        } catch (error) {
            console.error("Error initializing Firebase:", error);
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const nameScreen = document.getElementById('nameScreen');
        const characterSelectScreen = document.getElementById('characterSelectScreen');
        const restartBtn = document.getElementById('restartBtn');
        const pauseScreen = document.getElementById('pauseScreen');
        const resumeBtn = document.getElementById('resumeBtn');
        const countdownElement = document.getElementById('countdown');
        const highScoreList = document.getElementById('highScoreList');

        // Thêm debug khi nhấn nút Bắt đầu
        function showNameScreen() {
            console.log("showNameScreen called");
            startScreen.style.display = 'none';
            nameScreen.style.display = 'block';
        }

        let player = {
            x: 50,
            y: 300,
            width: 40,
            height: 50,
            dy: 0,
            dx: 0,
            gravity: 0.5,
            jumpPower: -12,
            moveSpeed: 5,
            isJumping: false,
            isCrouching: false,
            jumpCount: 0,
            maxJumps: 2,
            jumpEffect: 0,
            landEffect: 0,
            crashEffect: 0,
            legFrame: 0,
            groundTimer: 0,
            type: null,
            lives: 1,
            name: ''
        };

        let obstacles = [];
        let projectiles = [];
        let luckyStars = [];
        let meteors = [];
        let obstacleFrequency = 50;
        let luckyStarTimer = 0;
        const luckyStarFrequency = 600;
        let meteorTimer = 0;
        const meteorFrequency = 300;
        let meteorsToSpawn = 1;
        let projectileTimer = 0;
        let frameCount = 0;
        let score = 0;
        let gameOver = false;
        let gameStarted = false;
        let gamePaused = false;
        let countdown = 0;
        let baseSpeed = 5;
        let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;

        const obstacleSize = 40;
        const grenadeSize = 30;
        const luckyStarSize = 20;
        const meteorSize = 40;

        const stars = [];
        for (let i = 0; i < 50; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * (canvas.height - 50),
                size: Math.random() * 3 + 1,
                opacity: Math.random() * 0.5 + 0.5
            });
        }

        const taunts = [
            "Ôi, cái gì mà vụng quá vậy?",
            "Chạm cái là ngã, tập lại đi nhé!",
            "Điểm thấp thế này thì ai mà khen nổi?",
            "Né kiểu gì mà dở thế, thử lại nào!",
            "Chướng ngại vật cười vào mặt mày rồi kìa!",
            "Thật sự không làm vậy đâu, cố lên!",
            "Thua hoài vậy, định phá kỷ lục ngược hả?",
            "Mày làm tao buồn lòng lắm đó, chơi lại đi!",
            "Đụng là chết, phản xạ đâu rồi?",
            "Điểm cao hơn đi, đừng để tao thất vọng!"
        ];

        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (gameStarted && !gameOver) {
                if (e.code === 'ArrowUp' && player.jumpCount < player.maxJumps && !gamePaused) {
                    player.dy = player.jumpPower;
                    player.jumpCount++;
                    player.isJumping = true;
                    player.jumpEffect = 15;
                    player.groundTimer = 0;
                }
                if (e.code === 'ArrowDown' && !gamePaused) {
                    player.isCrouching = true;
                    player.height = player.type === 'car' ? 25 : 25;
                    if (!player.isJumping) player.y += 25;
                    else player.dy += 10;
                }
                if (e.code === 'Escape') {
                    if (!gameOver) {
                        if (!gamePaused) pauseGame();
                        else resumeGame();
                    }
                }
            }
            if (gameOver && e.code === 'Space') restartGame();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'ArrowDown' && !gamePaused) {
                player.isCrouching = false;
                player.height = player.type === 'car' ? 40 : 50;
                if (!player.isJumping) player.y -= 25;
            }
        });

        function spawnObstacle() {
            let types = ['ground', 'grenade', 'fireball', 'plane'];
            let type = types[Math.floor(Math.random() * types.length)];
            let speed = baseSpeed + (score / 500) + Math.floor(score / 100) * 0.2;

            if (type === 'ground') {
                obstacles.push({
                    x: canvas.width,
                    y: canvas.height - obstacleSize - 50,
                    width: obstacleSize,
                    height: obstacleSize,
                    speed: speed,
                    type: 'ground',
                    passed: false,
                    shootTimer: 0
                });
            } else if (type === 'grenade') {
                obstacles.push({
                    x: canvas.width,
                    y: canvas.height - grenadeSize - 50,
                    width: grenadeSize,
                    height: grenadeSize,
                    speed: speed,
                    type: 'grenade',
                    passed: false,
                    shootTimer: 0
                });
            } else if (type === 'fireball') {
                obstacles.push({
                    x: canvas.width,
                    y: Math.random() * (canvas.height - 150 - obstacleSize),
                    width: obstacleSize,
                    height: obstacleSize,
                    speed: speed,
                    dy: score >= 200 ? (Math.random() - 0.5) * 4 : 0,
                    flameOffset: 0,
                    type: 'fireball',
                    passed: false,
                    shootTimer: 0
                });
            } else {
                obstacles.push({
                    x: canvas.width,
                    y: Math.random() * (canvas.height - 150 - obstacleSize),
                    width: obstacleSize * 1.5,
                    height: obstacleSize,
                    speed: speed,
                    dy: score >= 200 ? (Math.random() - 0.5) * 4 : 0,
                    shootTimer: 0,
                    type: 'plane',
                    passed: false
                });
            }
        }

        function spawnLuckyStar() {
            luckyStars.push({
                x: canvas.width,
                y: Math.random() * (canvas.height - 150 - luckyStarSize) + 50,
                width: luckyStarSize,
                height: luckyStarSize,
                speed: baseSpeed / 2,
                collected: false
            });
        }

        function spawnMeteor() {
            for (let i = 0; i < meteorsToSpawn; i++) {
                let x;
                let attempts = 0;
                const maxAttempts = 10;
                do {
                    x = Math.random() * (canvas.width - meteorSize);
                    attempts++;
                } while (attempts < maxAttempts && meteors.some(meteor => Math.abs(meteor.x - x) < meteorSize * 1.5));

                meteors.push({
                    x: x,
                    y: -meteorSize,
                    width: meteorSize,
                    height: meteorSize,
                    dy: 10,
                    flameOffset: 0,
                    type: 'meteor',
                    shapePoints: generateRockShape()
                });
            }
        }

        function generateRockShape() {
            const points = [];
            const numPoints = 8;
            const radius = meteorSize / 2;
            for (let i = 0; i < numPoints; i++) {
                const angle = (Math.PI * 2 * i) / numPoints;
                const variation = (Math.random() * 0.3 + 0.7) * radius;
                const x = Math.cos(angle) * variation;
                const y = Math.sin(angle) * variation;
                points.push({ x, y });
            }
            return points;
        }

        function spawnProjectile() {
            let height = Math.random() * (canvas.height - 100);
            let projectileSpeed = 7 + (score / 1000) + Math.floor(score / 100) * 0.5;

            let isBullet = Math.random() > 0.5;

            if (isBullet) {
                projectiles.push({
                    x: canvas.width,
                    y: height,
                    width: 20,
                    height: 10,
                    speed: projectileSpeed,
                    type: 'bullet'
                });
            } else {
                projectiles.push({
                    x: canvas.width,
                    y: height,
                    width: 30,
                    height: 20,
                    speed: projectileSpeed,
                    type: 'fire'
                });
            }
        }

        function spawnPlaneBullet(plane) {
            let projectileSpeed = 7 + (score / 1000) + Math.floor(score / 100) * 0.5;
            projectiles.push({
                x: plane.x,
                y: plane.y + plane.height / 2,
                width: 15,
                height: 5,
                speed: projectileSpeed,
                type: 'planeBullet'
            });
        }

        function drawBackground() {
            const isNight = player.type && Math.floor(score / 400) % 2 === 1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = isNight ? '#000000' : '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height - 50);

            if (isNight) {
                stars.forEach(star => {
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

            if (player.type) {
                drawPlayer();
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Kỷ lục: ' + highScore, 10, 60);
                ctx.fillText('Mạng: ' + player.lives, 10, 90);
            }
        }

        function wrapText(text, maxWidth, x, y, fontSize, lineHeight) {
            ctx.font = `${fontSize}px Arial`;
            const words = text.split(' ');
            let line = '';
            let lines = [];
            let currentY = y;

            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;

                if (testWidth > maxWidth && i > 0) {
                    lines.push(line.trim());
                    line = words[i] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line.trim());

            lines.forEach((lineText, index) => {
                ctx.strokeText(lineText, x, currentY + index * lineHeight);
                ctx.fillText(lineText, x, currentY + index * lineHeight);
            });
        }

        function draw() {
            const isNight = Math.floor(score / 400) % 2 === 1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = isNight ? '#000000' : '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height - 50);

            if (isNight) {
                stars.forEach(star => {
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

            drawPlayer();
            luckyStars.forEach(star => drawLuckyStar(star));
            obstacles.forEach(obstacle => drawObstacle(obstacle));
            meteors.forEach(meteor => drawMeteor(meteor));
            projectiles.forEach(projectile => drawProjectile(projectile));

            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Điểm: ' + score, 10, 30);
            ctx.fillText('Kỷ lục: ' + highScore, 10, 60);
            ctx.fillText('Mạng: ' + player.lives, 10, 90);

            if (gameOver) {
                const randomTaunt = taunts[Math.floor(Math.random() * taunts.length)];
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 4;
                wrapText(randomTaunt, 700, canvas.width / 2 - 350, 40, 40, 45);

                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.fillText('Game Over! Điểm: ' + score, canvas.width / 2 - 150, canvas.height / 2 - 20);
                ctx.fillText('Kỷ lục: ' + highScore, canvas.width / 2 - 150, canvas.height / 2 + 30);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Nhấn Space để chơi lại hoặc Esc để tạm dừng', canvas.width / 2 - 180, canvas.height / 2 + 70);
                restartBtn.style.display = 'block';
            }
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
            const isNight = Math.floor(score / 400) % 2 === 1;

            if (player.jumpEffect > 0) {
                ctx.beginPath();
                ctx.arc(0, player.height / 2, player.jumpEffect * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${player.jumpEffect / 15})`;
                ctx.fill();
                player.jumpEffect--;
            }

            if (player.landEffect > 0) {
                ctx.beginPath();
                ctx.arc(0, player.height / 2, player.landEffect * 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(139, 69, 19, ${player.landEffect / 10})`;
                ctx.fill();
                player.landEffect--;
            }

            if (player.crashEffect > 0) {
                ctx.beginPath();
                ctx.arc(0, 0, player.crashEffect * 5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 0, 0, ${player.crashEffect / 20})`;
                ctx.fill();
                player.crashEffect--;
            }

            if (player.type === 'ninja') {
                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    if (player.isCrouching) ctx.rect(-10, -10, 20, 20);
                    else ctx.rect(-10, -20, 20, 40);
                    ctx.stroke();
                }

                const bodyGradient = ctx.createLinearGradient(0, -player.height / 2, 0, player.height / 2);
                bodyGradient.addColorStop(0, '#FF4500');
                bodyGradient.addColorStop(1, '#8B0000');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                if (player.isCrouching) ctx.rect(-10, -10, 20, 20);
                else ctx.rect(-10, -20, 20, 40);
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(0, player.isCrouching ? -15 : -25, 10, 0, Math.PI * 2);
                ctx.fill();
                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(-3, player.isCrouching ? -15 : -25, 2, 0, Math.PI * 2);
                ctx.arc(3, player.isCrouching ? -15 : -25, 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                if (player.isCrouching) {
                    ctx.rect(-15, -5, 10, 5);
                    ctx.rect(5, -5, 10, 5);
                } else {
                    ctx.rect(-15, -15, 10, 5);
                    ctx.rect(5, -15, 10, 5);
                }
                ctx.fill();
                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.fillStyle = '#8B0000';
                if (player.isCrouching) {
                    ctx.beginPath();
                    ctx.rect(-5, 5, 5, 5);
                    ctx.rect(0, 5, 5, 5);
                    ctx.fill();
                    if (isNight) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } else if (!player.isJumping) {
                    let legOffset = Math.sin(player.legFrame * 0.3) * 5;
                    ctx.beginPath();
                    ctx.rect(-5, 15 + legOffset, 5, 10 - legOffset);
                    ctx.rect(0, 15 - legOffset, 5, 10 + legOffset);
                    ctx.fill();
                    if (isNight) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                } else {
                    ctx.beginPath();
                    ctx.rect(-5, 10, 5, 5);
                    ctx.rect(0, 10, 5, 5);
                    ctx.fill();
                    if (isNight) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            } else if (player.type === 'dinosaur') {
                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-20, player.isCrouching ? 0 : 10);
                    ctx.lineTo(20, player.isCrouching ? 0 : 10);
                    ctx.lineTo(10, player.isCrouching ? -10 : -25);
                    ctx.lineTo(-10, player.isCrouching ? -10 : -25);
                    ctx.closePath();
                    ctx.stroke();
                }

                ctx.fillStyle = '#006400';
                ctx.beginPath();
                ctx.moveTo(-20, player.isCrouching ? 0 : 10);
                ctx.lineTo(20, player.isCrouching ? 0 : 10);
                ctx.lineTo(10, player.isCrouching ? -10 : -25);
                ctx.lineTo(-10, player.isCrouching ? -10 : -25);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(player.isCrouching ? 5 : 0, player.isCrouching ? -15 : -30, 3, 0, Math.PI * 2);
                ctx.fill();

                if (!player.isJumping && !player.isCrouching) {
                    let legOffset = Math.sin(player.legFrame * 0.3) * 5;
                    ctx.fillStyle = '#006400';
                    ctx.beginPath();
                    ctx.rect(-10, 10 + legOffset, 5, 10 - legOffset);
                    ctx.rect(5, 10 - legOffset, 5, 10 + legOffset);
                    ctx.fill();
                    if (isNight) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            } else if (player.type === 'car') {
                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.rect(-20, player.isCrouching ? -10 : -20, 40, player.isCrouching ? 20 : 30);
                    ctx.stroke();
                }

                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.rect(-20, player.isCrouching ? -10 : -20, 40, player.isCrouching ? 20 : 30);
                ctx.fill();

                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(-10, 10, 5, 0, Math.PI * 2);
                ctx.arc(10, 10, 5, 0, Math.PI * 2);
                ctx.fill();
                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.fillStyle = '#87CEEB';
                ctx.beginPath();
                ctx.rect(-5, player.isCrouching ? -5 : -15, 10, 5);
                ctx.fill();
            } else if (player.type === 'basketball') {
                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 20, Math.PI / 4, 3 * Math.PI / 4);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, 20, 5 * Math.PI / 4, 7 * Math.PI / 4);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-14, 14);
                ctx.lineTo(14, -14);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawLuckyStar(star) {
            ctx.save();
            ctx.translate(star.x + star.width / 2, star.y + star.height / 2);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            const points = 5;
            const outerRadius = star.width / 2;
            const innerRadius = outerRadius / 2;
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (Math.PI / points) * i - Math.PI / 2;
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function drawMeteor(meteor) {
            ctx.save();
            ctx.translate(meteor.x + meteor.width / 2, meteor.y + meteor.height / 2);
            const isNight = Math.floor(score / 400) % 2 === 1;

            ctx.fillStyle = '#808080';
            ctx.beginPath();
            const points = meteor.shapePoints;
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'rgba(90, 90, 90, 0.5)';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length / 2; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.fill();

            const flameGradient = ctx.createRadialGradient(
                0, 0, 0,
                0, 15, meteor.width / 2 + 15
            );
            flameGradient.addColorStop(0, 'rgba(255, 69, 0, 0.8)');
            flameGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');

            meteor.flameOffset = (meteor.flameOffset + 0.1) % (Math.PI * 2);
            ctx.fillStyle = flameGradient;
            ctx.beginPath();
            ctx.ellipse(0, 10, meteor.width / 2 + 10 * Math.sin(meteor.flameOffset), meteor.height / 2 + 15, 0, 0, Math.PI * 2);
            ctx.fill();

            if (isNight) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawObstacle(obstacle) {
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);
            const isNight = Math.floor(score / 400) % 2 === 1;

            if (obstacle.type === 'ground') {
                const gradient = ctx.createLinearGradient(0, 0, 0, obstacle.height);
                gradient.addColorStop(0, '#808080');
                gradient.addColorStop(1, '#2F2F2F');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, obstacle.height);
                ctx.lineTo(obstacle.width / 3, obstacle.height / 2);
                ctx.lineTo(obstacle.width / 2, 0);
                ctx.lineTo(obstacle.width, obstacle.height / 3);
                ctx.lineTo(obstacle.width, obstacle.height);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = isNight ? 'white' : '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
            } else if (obstacle.type === 'grenade') {
                ctx.fillStyle = '#4B5320';
                ctx.beginPath();
                ctx.moveTo(5, obstacle.height);
                ctx.lineTo(obstacle.width - 5, obstacle.height);
                ctx.quadraticCurveTo(obstacle.width, obstacle.height - 5, obstacle.width, obstacle.height / 2);
                ctx.lineTo(obstacle.width, 10);
                ctx.quadraticCurveTo(obstacle.width - 5, 0, obstacle.width / 2, 0);
                ctx.lineTo(obstacle.width / 2 - 5, 0);
                ctx.quadraticCurveTo(0, 0, 0, 10);
                ctx.lineTo(0, obstacle.height / 2);
                ctx.quadraticCurveTo(0, obstacle.height - 5, 5, obstacle.height);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#2F2F2F';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(obstacle.width / 2, 0);
                ctx.lineTo(obstacle.width / 2, obstacle.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(obstacle.width / 4, obstacle.height / 4);
                ctx.lineTo(obstacle.width * 3 / 4, obstacle.height * 3 / 4);
                ctx.stroke();

                ctx.fillStyle = '#808080';
                ctx.beginPath();
                ctx.rect(obstacle.width / 2 - 5, -5, 10, 5);
                ctx.fill();

                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(5, obstacle.height);
                    ctx.lineTo(obstacle.width - 5, obstacle.height);
                    ctx.quadraticCurveTo(obstacle.width, obstacle.height - 5, obstacle.width, obstacle.height / 2);
                    ctx.lineTo(obstacle.width, 10);
                    ctx.quadraticCurveTo(obstacle.width - 5, 0, obstacle.width / 2, 0);
                    ctx.lineTo(obstacle.width / 2 - 5, 0);
                    ctx.quadraticCurveTo(0, 0, 0, 10);
                    ctx.lineTo(0, obstacle.height / 2);
                    ctx.quadraticCurveTo(0, obstacle.height - 5, 5, obstacle.height);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.rect(obstacle.width / 2 - 5, -5, 10, 5);
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            } else if (obstacle.type === 'fireball') {
                const gradient = ctx.createRadialGradient(
                    obstacle.width / 2, obstacle.height / 2, 0,
                    obstacle.width / 2, obstacle.height / 2, obstacle.width / 2
                );
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FF4500');
                gradient.addColorStop(1, '#FF0000');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(obstacle.width / 2, obstacle.height / 2, obstacle.width / 2, 0, Math.PI * 2);
                ctx.fill();

                obstacle.flameOffset = (obstacle.flameOffset + 0.1) % (Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 69, 0, 0.7)';
                ctx.beginPath();
                ctx.arc(obstacle.width / 2, obstacle.height / 2 - 15, 15 + 10 * Math.sin(obstacle.flameOffset), 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(obstacle.width / 2 + 10 * Math.sin(obstacle.flameOffset + 1), obstacle.height / 2 - 20, 20 + 5 * Math.cos(obstacle.flameOffset), 0, Math.PI * 2);
                ctx.fill();
            } else {
                const gradient = ctx.createLinearGradient(0, 0, obstacle.width, 0);
                gradient.addColorStop(0, '#D3D3D3');
                gradient.addColorStop(1, '#4682B4');
                ctx.fillStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(0, obstacle.height / 2);
                ctx.lineTo(obstacle.width / 4, obstacle.height / 4);
                ctx.lineTo(obstacle.width - 10, obstacle.height / 4);
                ctx.lineTo(obstacle.width, 0);
                ctx.lineTo(obstacle.width - 10, obstacle.height * 3 / 4);
                ctx.lineTo(obstacle.width / 4, obstacle.height * 3 / 4);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(obstacle.width / 2 - 10, obstacle.height / 2);
                ctx.lineTo(obstacle.width / 2 + 20, obstacle.height / 2 - 15);
                ctx.lineTo(obstacle.width / 2 + 40, obstacle.height / 2 - 5);
                ctx.lineTo(obstacle.width / 2 + 20, obstacle.height / 2 + 5);
                ctx.fillStyle = '#4682B4';
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(10, obstacle.height / 2);
                ctx.lineTo(20, obstacle.height / 2 - 10);
                ctx.lineTo(30, obstacle.height / 2 - 5);
                ctx.lineTo(20, obstacle.height / 2 + 10);
                ctx.fillStyle = '#D3D3D3';
                ctx.fill();

                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(obstacle.width - 20, obstacle.height / 2, 5, 0, Math.PI * 2);
                ctx.fill();

                if (isNight) {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, obstacle.height / 2);
                    ctx.lineTo(obstacle.width / 4, obstacle.height / 4);
                    ctx.lineTo(obstacle.width - 10, obstacle.height / 4);
                    ctx.lineTo(obstacle.width, 0);
                    ctx.lineTo(obstacle.width - 10, obstacle.height * 3 / 4);
                    ctx.lineTo(obstacle.width / 4, obstacle.height * 3 / 4);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(obstacle.width / 2 - 10, obstacle.height / 2);
                    ctx.lineTo(obstacle.width / 2 + 20, obstacle.height / 2 - 15);
                    ctx.lineTo(obstacle.width / 2 + 40, obstacle.height / 2 - 5);
                    ctx.lineTo(obstacle.width / 2 + 20, obstacle.height / 2 + 5);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(10, obstacle.height / 2);
                    ctx.lineTo(20, obstacle.height / 2 - 10);
                    ctx.lineTo(30, obstacle.height / 2 - 5);
                    ctx.lineTo(20, obstacle.height / 2 + 10);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(obstacle.width - 20, obstacle.height / 2, 5, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function drawProjectile(projectile) {
            ctx.save();
            ctx.translate(projectile.x, projectile.y);
            const isNight = Math.floor(score / 400) % 2 === 1;

            if (projectile.type === 'bullet') {
                const gradient = ctx.createLinearGradient(0, 0, projectile.width, 0);
                gradient.addColorStop(0, '#C0C0C0');
                gradient.addColorStop(1, '#808080');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, projectile.height / 2);
                ctx.lineTo(projectile.width / 2, 0);
                ctx.lineTo(projectile.width, 0);
                ctx.lineTo(projectile.width, projectile.height);
                ctx.lineTo(projectile.width / 2, projectile.height);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = isNight ? 'white' : '#404040';
                ctx.lineWidth = isNight ? 2 : 1;
                ctx.stroke();
            } else if (projectile.type === 'fire') {
                const gradient = ctx.createRadialGradient(
                    projectile.width / 2, projectile.height / 2, 0,
                    projectile.width / 2, projectile.height / 2, projectile.width / 2
                );
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FF4500');
                gradient.addColorStop(1, '#FF0000');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, projectile.height);
                ctx.quadraticCurveTo(projectile.width / 2, -projectile.height / 2, projectile.width, projectile.height);
                ctx.lineTo(projectile.width, 0);
                ctx.quadraticCurveTo(projectile.width / 2, projectile.height * 1.5, 0, 0);
                ctx.closePath();
                ctx.fill();
            } else if (projectile.type === 'planeBullet') {
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.rect(0, 0, projectile.width, projectile.height);
                ctx.fill();
                ctx.strokeStyle = isNight ? 'white' : '#404040';
                ctx.lineWidth = isNight ? 2 : 1;
                ctx.stroke();
            }

            ctx.restore();
        }

        function update() {
            if (!gameStarted) {
                drawBackground();
                return;
            }

            if (gamePaused || gameOver) {
                draw();
                return;
            }

            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.moveSpeed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) player.x += player.moveSpeed;

            player.dy += player.gravity;
            player.y += player.dy;

            if (player.y > canvas.height - player.height - 50) {
                if (player.dy > 0 && !player.landEffect) player.landEffect = 10;
                player.y = canvas.height - player.height - 50;
                player.dy = 0;
                player.isJumping = false;
                player.jumpCount = 0;
                player.groundTimer++;
            } else {
                player.groundTimer = 0;
            }

            if (!player.isJumping && !player.isCrouching) player.legFrame++;
            else player.legFrame = 0;

            frameCount++;

            meteorsToSpawn = Math.min(5, Math.floor(score / 200) + 1);

            obstacleFrequency = score >= 200 ? Math.max(20, 50 - Math.floor((score - 200) / 25) * 5) : 50;
            if (frameCount % obstacleFrequency === 0) spawnObstacle();

            luckyStarTimer++;
            if (luckyStarTimer >= luckyStarFrequency && Math.random() < 0.05) {
                spawnLuckyStar();
                luckyStarTimer = 0;
            }

            meteorTimer++;
            if (meteorTimer >= meteorFrequency) {
                spawnMeteor();
                meteorTimer = 0;
            }

            if (player.groundTimer >= 180) {
                spawnObstacle();
                player.groundTimer = 0;
            }

            projectileTimer++;
            if (projectileTimer >= 300) {
                spawnProjectile();
                projectileTimer = 0;
            }

            for (let i = luckyStars.length - 1; i >= 0; i--) {
                let star = luckyStars[i];
                if (!star) continue;
                star.x -= star.speed;

                if (star.x + star.width < 0) {
                    luckyStars.splice(i, 1);
                    continue;
                }

                if (
                    player.x + player.width > star.x &&
                    player.x < star.x + star.width &&
                    player.y + player.height > star.y &&
                    player.y < star.y + star.height &&
                    !star.collected
                ) {
                    star.collected = true;
                    player.lives++;
                    luckyStars.splice(i, 1);
                }
            }

            for (let i = meteors.length - 1; i >= 0; i--) {
                let meteor = meteors[i];
                if (!meteor) continue;
                meteor.y += meteor.dy;

                if (meteor.y > canvas.height) {
                    meteors.splice(i, 1);
                    continue;
                }

                if (
                    player.x + player.width > meteor.x &&
                    player.x < meteor.x + meteor.width &&
                    player.y + player.height > meteor.y &&
                    player.y < meteor.y + meteor.height
                ) {
                    if (player.lives > 1) {
                        player.lives--;
                        player.crashEffect = 20;
                        meteors.splice(i, 1);
                    } else {
                        gameOver = true;
                        player.crashEffect = 20;
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('highScore', highScore);
                        }
                        updateHighScore(player.name, score);
                    }
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obstacle = obstacles[i];
                if (!obstacle) continue;
                obstacle.x -= obstacle.speed;

                if ((obstacle.type === 'fireball' || obstacle.type === 'plane') && score >= 200) {
                    obstacle.y += obstacle.dy || 0;
                    if (obstacle.y < 0 || obstacle.y > canvas.height - obstacle.height - 50) {
                        obstacle.dy = -(obstacle.dy || 0);
                    }
                }

                if (obstacle.type === 'plane') {
                    obstacle.shootTimer = (obstacle.shootTimer || 0) + 1;
                    if (obstacle.shootTimer >= 60) {
                        spawnPlaneBullet(obstacle);
                        obstacle.shootTimer = 0;
                    }
                }

                if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
                    score += 10;
                    obstacle.passed = true;
                }

                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(i, 1);
                    continue;
                }

                if (
                    player.x + player.width > obstacle.x &&
                    player.x < obstacle.x + obstacle.width &&
                    player.y + player.height > obstacle.y &&
                    player.y < obstacle.y + obstacle.height
                ) {
                    if (player.lives > 1) {
                        player.lives--;
                        player.crashEffect = obstacle.type === 'grenade' ? 30 : 20;
                        obstacles.splice(i, 1);
                    } else {
                        gameOver = true;
                        player.crashEffect = obstacle.type === 'grenade' ? 30 : 20;
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('highScore', highScore);
                        }
                        updateHighScore(player.name, score);
                    }
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                let projectile = projectiles[i];
                if (!projectile) continue;
                projectile.x -= projectile.speed;

                if (projectile.x + projectile.width < 0) {
                    projectiles.splice(i, 1);
                    continue;
                }

                if (
                    player.x + player.width > projectile.x &&
                    player.x < projectile.x + projectile.width &&
                    player.y + player.height > projectile.y &&
                    player.y < projectile.y + projectile.height
                ) {
                    if (player.lives > 1) {
                        player.lives--;
                        player.crashEffect = 20;
                        projectiles.splice(i, 1);
                    } else {
                        gameOver = true;
                        player.crashEffect = 20;
                        if (score > highScore) {
                            highScore = score;
                            localStorage.setItem('highScore', highScore);
                        }
                        updateHighScore(player.name, score);
                    }
                }
            }

            draw();
            requestAnimationFrame(update);
        }

        function showNameScreen() {
            startScreen.style.display = 'none';
            nameScreen.style.display = 'block';
        }

        function submitName() {
            const nameInput = document.getElementById('playerName').value.trim();
            if (nameInput) {
                player.name = nameInput;
                nameScreen.style.display = 'none';
                characterSelectScreen.style.display = 'block';
                loadHighScores();
            } else {
                alert('Vui lòng nhập tên!');
            }
        }

        function startGame(characterType) {
            player.type = characterType;
            player.height = characterType === 'car' ? 40 : 50;
            player.lives = 1;
            gameStarted = true;
            characterSelectScreen.style.display = 'none';
            requestAnimationFrame(update);
        }

        function restartGame() {
            player.x = 50;
            player.y = 300;
            player.dy = 0;
            player.dx = 0;
            player.isJumping = false;
            player.isCrouching = false;
            player.height = player.type === 'car' ? 40 : 50;
            player.jumpCount = 0;
            player.legFrame = 0;
            player.groundTimer = 0;
            player.lives = 1;
            obstacles = [];
            projectiles = [];
            meteors = [];
            luckyStars = [];
            obstacleFrequency = 50;
            luckyStarTimer = 0;
            meteorTimer = 0;
            meteorsToSpawn = 1;
            frameCount = 0;
            projectileTimer = 0;
            score = 0;
            gameOver = false;
            gamePaused = false;
            restartBtn.style.display = 'none';
            requestAnimationFrame(update);
        }

        function pauseGame() {
            if (!gameOver && gameStarted) {
                gamePaused = true;
                pauseScreen.style.display = 'block';
                draw();
            }
        }

        function resumeGame() {
            countdown = 3;
            resumeBtn.disabled = true;
            let countdownInterval = setInterval(() => {
                countdownElement.textContent = `Tiếp tục trong ${countdown} giây`;
                countdown--;
                if (countdown < 0) {
                    clearInterval(countdownInterval);
                    gamePaused = false;
                    pauseScreen.style.display = 'none';
                    resumeBtn.disabled = false;
                    countdownElement.textContent = '';
                    requestAnimationFrame(update);
                }
            }, 1000);
        }

        function updateHighScore(name, score) {
            const highScoreRef = database.ref('highScores/' + name);
            highScoreRef.once('value', (snapshot) => {
                const currentHighScore = snapshot.val() ? snapshot.val().score : 0;
                if (score > currentHighScore) {
                    highScoreRef.set({
                        name: name,
                        score: score
                    });
                }
            });
        }

        function loadHighScores() {
            database.ref('highScores').orderByChild('score').limitToLast(5).on('value', (snapshot) => {
                highScoreList.innerHTML = '';
                const scores = [];
                snapshot.forEach((childSnapshot) => {
                    const data = childSnapshot.val();
                    scores.push(data);
                });
                scores.sort((a, b) => b.score - a.score);
                scores.slice(0, 5).forEach((entry) => {
                    const li = document.createElement('li');
                    li.textContent = `${entry.name}: ${entry.score}`;
                    highScoreList.appendChild(li);
                });
            });
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height - 50);
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
    </script>
</body>
</html>